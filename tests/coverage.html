
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>apperror: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/myacey/avito-shop/internal/apperror/apperror.go (66.7%)</option>
				
				<option value="file1">github.com/myacey/avito-shop/internal/backconfig/config.go (0.0%)</option>
				
				<option value="file2">github.com/myacey/avito-shop/internal/controller/api.go (90.9%)</option>
				
				<option value="file3">github.com/myacey/avito-shop/internal/controller/controller.go (100.0%)</option>
				
				<option value="file4">github.com/myacey/avito-shop/internal/controller/middleware.go (0.0%)</option>
				
				<option value="file5">github.com/myacey/avito-shop/internal/hasher/hasher.go (5.9%)</option>
				
				<option value="file6">github.com/myacey/avito-shop/internal/jwttoken/jwt.go (0.0%)</option>
				
				<option value="file7">github.com/myacey/avito-shop/internal/mocks/hasher_mock.go (100.0%)</option>
				
				<option value="file8">github.com/myacey/avito-shop/internal/mocks/inventory_repository_mock.go (100.0%)</option>
				
				<option value="file9">github.com/myacey/avito-shop/internal/mocks/jwt_mock.go (100.0%)</option>
				
				<option value="file10">github.com/myacey/avito-shop/internal/mocks/queries_mock.go (91.2%)</option>
				
				<option value="file11">github.com/myacey/avito-shop/internal/mocks/service_mock.go (81.1%)</option>
				
				<option value="file12">github.com/myacey/avito-shop/internal/mocks/session_repository_mock.go (100.0%)</option>
				
				<option value="file13">github.com/myacey/avito-shop/internal/mocks/store_repository_mock.go (100.0%)</option>
				
				<option value="file14">github.com/myacey/avito-shop/internal/mocks/transfer_repository_mock.go (100.0%)</option>
				
				<option value="file15">github.com/myacey/avito-shop/internal/mocks/user_repository_mock.go (100.0%)</option>
				
				<option value="file16">github.com/myacey/avito-shop/internal/repository/postgresrepo/inventory_repo.go (100.0%)</option>
				
				<option value="file17">github.com/myacey/avito-shop/internal/repository/postgresrepo/postgres.go (25.0%)</option>
				
				<option value="file18">github.com/myacey/avito-shop/internal/repository/postgresrepo/store_repo.go (100.0%)</option>
				
				<option value="file19">github.com/myacey/avito-shop/internal/repository/postgresrepo/transfer_repo.go (100.0%)</option>
				
				<option value="file20">github.com/myacey/avito-shop/internal/repository/postgresrepo/user_repo.go (100.0%)</option>
				
				<option value="file21">github.com/myacey/avito-shop/internal/repository/redisrepo/redis.go (0.0%)</option>
				
				<option value="file22">github.com/myacey/avito-shop/internal/repository/redisrepo/session_repository.go (0.0%)</option>
				
				<option value="file23">github.com/myacey/avito-shop/internal/service/service.go (100.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package apperror

import (
        "fmt"
        "net/http"
)

type AppError struct {
        HTTPCode int    // for user
        Message  string // for user
        Err      error  // for internal logging
}

func (e *AppError) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("HTTP %d: %s - %v", e.HTTPCode, e.Message, e.Err)
}</span>

func (e *AppError) Unwrap() error <span class="cov0" title="0">{
        return e.Err
}</span>

// NewBadReq used to create errors with
// statusCode = 400.
func NewBadReq(message string, err error) *AppError <span class="cov6" title="9">{
        return &amp;AppError{HTTPCode: http.StatusBadRequest, Message: message, Err: fmt.Errorf("%s: %w", message, err)}
}</span>

// NewUnauthorized used to create errors with
// statusCode = 401.
func NewUnauthorized(message string, err error) *AppError <span class="cov5" title="8">{
        return &amp;AppError{HTTPCode: http.StatusUnauthorized, Message: message, Err: fmt.Errorf("%s: %w", message, err)}
}</span>

// NewNotFound used to create errors with
// statusCode = 404.
func NewNotFound(message string, err error) *AppError <span class="cov5" title="8">{
        return &amp;AppError{HTTPCode: http.StatusNotFound, Message: message, Err: fmt.Errorf("%s: %w", message, err)}
}</span>

// NewInternal used to craete errors with
// statusCode = 500.
func NewInternal(message string, err error) *AppError <span class="cov10" title="45">{
        return &amp;AppError{HTTPCode: http.StatusInternalServerError, Message: message, Err: fmt.Errorf("%s: %w", message, err)}
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package backconfig

import "github.com/spf13/viper"

type Config struct {
        // 4ALL
        ServerPort   string `mapstructure:"SERVER_PORT"`
        DBPassword   string `mapstructure:"DB_PASSWORD"`
        Testing      bool   `mapstructure:"TESTING"`
        JWTSecretKey string `mapstructure:"JWT_SECRET_KEY"`

        // POSTGRES
        PostgresHost   string `mapstructure:"POSTGRES_HOST"`
        PostgresUser   string `mapstructure:"POSTGRES_USER"`
        PostgresDBName string `mapstructure:"POSTGRES_DB"`
        PostgresPort   string `mapstructure:"POSTGRES_PORT"`

        // REDIS
        RedisUser string `mapstructure:"REDIS_USER"`
        RedisHost string `mapstructure:"REDIS_HOST"`
}

func LoadConfig() (config Config, err error) <span class="cov0" title="0">{
        viper.SetConfigFile(".env")

        viper.AutomaticEnv()

        err = viper.ReadInConfig()
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">err = viper.Unmarshal(&amp;config)
        return</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package controller

import (
        "net/http"

        "github.com/gin-gonic/gin"
        "github.com/myacey/avito-shop/internal/apperror"
)

type authReq struct {
        Username string `json:"username"`
        Password string `json:"password"`
}

// Authorize checks providen userame and password.
//
// If user exists -&gt; give access token.
//
// If user dont exists -&gt; create new one and give access token.
func (h *Controller) Authorize(c *gin.Context) <span class="cov5" title="2">{
        var req authReq
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                h.JSONError(c, err)
                return
        }</span>

        <span class="cov5" title="2">token, err := h.srv.AuthorizeUser(c, req.Username, req.Password)
        if err != nil </span><span class="cov1" title="1">{
                h.JSONError(c, err)
                return
        }</span>

        <span class="cov1" title="1">c.JSON(http.StatusOK, gin.H{"token": token})</span>
}

// GetFullInfo checks providen token with middleware and
// then gets dbUser, dbTransactionHistory and dbInventory.
func (h *Controller) GetFullUserInfo(c *gin.Context) <span class="cov8" title="3">{
        username, ok := c.Get("username")
        if !ok </span><span class="cov1" title="1">{
                h.JSONError(c, apperror.NewInternal("no username in token", nil))
                return
        }</span>

        <span class="cov5" title="2">usr, err := h.srv.GetFullUserInfo(c, username.(string))
        if err != nil </span><span class="cov1" title="1">{
                h.JSONError(c, err)
                return
        }</span>

        <span class="cov1" title="1">c.JSON(http.StatusOK, usr)</span>
}

type sendCoinReq struct {
        ToUser string `json:"toUser"`
        Amount int32  `json:"amount"`
}

// SendCoins checks providen token with middleware and
// than transfers money from one user to another.
func (h *Controller) SendCoins(c *gin.Context) <span class="cov8" title="3">{
        username, ok := c.Get("username")
        if !ok </span><span class="cov1" title="1">{
                h.JSONError(c, apperror.NewInternal("no username in token", nil))
                return
        }</span>

        <span class="cov5" title="2">var req sendCoinReq
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                h.JSONError(c, err)
                return
        }</span>

        <span class="cov5" title="2">err := h.srv.SendCoin(c, username.(string), req.ToUser, req.Amount)
        if err != nil </span><span class="cov1" title="1">{
                h.JSONError(c, err)
                return
        }</span>

        <span class="cov1" title="1">c.JSON(http.StatusOK, nil)</span>
}

func (h *Controller) BuyItem(c *gin.Context) <span class="cov10" title="4">{
        username, ok := c.Get("username")
        if !ok </span><span class="cov1" title="1">{
                h.JSONError(c, apperror.NewInternal("no username in token", nil))
                return
        }</span>

        <span class="cov8" title="3">item := c.Param("item")
        if item == "" </span><span class="cov1" title="1">{
                h.JSONError(c, apperror.NewBadReq("invalid item", nil))
                return
        }</span>

        <span class="cov5" title="2">err := h.srv.BuyItem(c, username.(string), item)
        if err != nil </span><span class="cov1" title="1">{
                h.JSONError(c, err)
                return
        }</span>

        <span class="cov1" title="1">c.JSON(http.StatusOK, nil)</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package controller

import (
        "errors"
        "fmt"
        "log"
        "net/http"
        "os"

        "github.com/gin-gonic/gin"
        "github.com/myacey/avito-shop/internal/apperror"
        "github.com/myacey/avito-shop/internal/service"
)

type Controller struct {
        srv service.Interface

        testingStatus bool
}

func NewController(srv service.Interface) *Controller <span class="cov7" title="4">{
        testingStatus := os.Getenv("STATUS") == "testing"
        return &amp;Controller{srv, testingStatus}
}</span>

func (h *Controller) JSONError(c *gin.Context, err error) <span class="cov10" title="8">{
        var appErr *apperror.AppError
        if errors.As(err, &amp;appErr) </span><span class="cov7" title="4">{
                if appErr.HTTPCode == http.StatusInternalServerError </span><span class="cov5" title="3">{
                        log.Printf("Internal error! user message: %s", appErr.Message)
                }</span>
                <span class="cov7" title="4">log.Printf("error: %s", fmt.Sprint(appErr.Err))
                c.JSON(appErr.HTTPCode, gin.H{"errors": appErr.Message})
                return</span>
        }

        <span class="cov7" title="4">log.Printf("Unexpected error: %v", err.Error())
        c.JSON(http.StatusInternalServerError, gin.H{"errors": "internal server error"})</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package controller

import (
        "log"
        "net/http"
        "strings"

        "github.com/gin-gonic/gin"
        "github.com/myacey/avito-shop/internal/apperror"
)

func (h *Controller) AuthMiddleware() gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                if c.Request.Method == http.MethodOptions </span><span class="cov0" title="0">{
                        c.Next()
                }</span>

                <span class="cov0" title="0">if h.testingStatus </span><span class="cov0" title="0">{
                        log.Print("&gt;&gt; TESTING, skip auth")
                        c.Set("username", "testuser")
                        c.Next()
                        return
                }</span>

                <span class="cov0" title="0">authHeader := c.GetHeader("Authorization")

                bearerToken := strings.Split(authHeader, " ")
                if bearerToken[0] != "Bearer" || len(bearerToken) != 2 </span><span class="cov0" title="0">{
                        h.JSONError(c, apperror.NewUnauthorized("invalid token", nil))
                        c.Abort()
                        return
                }</span>

                <span class="cov0" title="0">usrname, err := h.srv.CheckAuthToken(c, bearerToken[1])
                if err != nil </span><span class="cov0" title="0">{
                        h.JSONError(c, err)
                        c.Abort()
                        return
                }</span>

                <span class="cov0" title="0">c.Set("username", usrname)
                c.Next()</span>
        }
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package hasher

import (
        "errors"

        "golang.org/x/crypto/bcrypt"
)

type Hasher interface {
        Generate(password string) (string, error)
        Compare(hash, password string) error
}

const (
        // maxConcurrentBcryptOps represents a max bcrypt operation count.
        maxConcurrentBcryptOps = 20
)

var (
        bcryptSemaphore chan struct{}

        ErrToLong      = errors.New("providen password too long")
        ErrDontCompare = errors.New("passwords dont match")
)

type BcryptHasher struct{}

func init() <span class="cov10" title="2">{
        bcryptSemaphore = make(chan struct{}, maxConcurrentBcryptOps)
}</span>

func (b *BcryptHasher) Generate(password string) (string, error) <span class="cov0" title="0">{
        bcryptSemaphore &lt;- struct{}{}
        defer func() </span><span class="cov0" title="0">{ &lt;-bcryptSemaphore }</span>()

        <span class="cov0" title="0">bytes, err := bcrypt.GenerateFromPassword([]byte(password), bcrypt.MinCost)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, bcrypt.ErrPasswordTooLong) </span><span class="cov0" title="0">{
                        return "", ErrToLong
                }</span>
                <span class="cov0" title="0">return "", err</span>
        }
        <span class="cov0" title="0">return string(bytes), err</span>

        // return password, nil
}

func (b *BcryptHasher) Compare(hash, password string) error <span class="cov0" title="0">{
        bcryptSemaphore &lt;- struct{}{}
        defer func() </span><span class="cov0" title="0">{ &lt;-bcryptSemaphore }</span>()

        <span class="cov0" title="0">res := bcrypt.CompareHashAndPassword([]byte(hash), []byte(password))
        if errors.Is(res, bcrypt.ErrMismatchedHashAndPassword) </span><span class="cov0" title="0">{
                return ErrDontCompare
        }</span>

        <span class="cov0" title="0">return res</span>

        // if hash == password {
        //         return nil
        // }
        // return ErrDontCompare
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package jwttoken

import (
        "errors"
        "time"

        "github.com/golang-jwt/jwt/v5"
)

var (
        ErrInvalidKey   = errors.New("invalid authorization key")
        ErrTokenExpired = errors.New("auth token expired")
)

type TokenMakerInterface interface {
        CreateToken(username string) (string, error)
        VerifyToken(tokenString string) (string, error)
}

type TokenMaker struct {
        secretKey []byte
        ttl       time.Duration
}

func CreateTokenMaker(secretKey []byte, ttl time.Duration) TokenMakerInterface <span class="cov0" title="0">{
        return &amp;TokenMaker{secretKey, ttl}
}</span>

func (tm *TokenMaker) CreateToken(username string) (string, error) <span class="cov0" title="0">{
        token := jwt.NewWithClaims(jwt.SigningMethodHS256,
                jwt.MapClaims{
                        "username": username,
                        "exp":      time.Now().Add(tm.ttl).Unix(),
                })

        return token.SignedString(tm.secretKey)
}</span>

func (tm *TokenMaker) VerifyToken(tokenString string) (string, error) <span class="cov0" title="0">{
        token, err := jwt.Parse(tokenString, func(_ *jwt.Token) (interface{}, error) </span><span class="cov0" title="0">{
                return tm.secretKey, nil
        }</span>)
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, jwt.ErrTokenExpired) </span><span class="cov0" title="0">{
                        return "", ErrTokenExpired
                }</span>
                <span class="cov0" title="0">return "", ErrInvalidKey</span>
        }

        <span class="cov0" title="0">if claims, ok := token.Claims.(jwt.MapClaims); ok </span><span class="cov0" title="0">{
                return claims["username"].(string), nil
        }</span>

        <span class="cov0" title="0">return "", ErrInvalidKey</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: internal/hasher/hasher.go

// Package mocks is a generated GoMock package.
package mocks

import (
        reflect "reflect"

        gomock "github.com/golang/mock/gomock"
)

// MockHasher is a mock of Hasher interface.
type MockHasher struct {
        ctrl     *gomock.Controller
        recorder *MockHasherMockRecorder
}

// MockHasherMockRecorder is the mock recorder for MockHasher.
type MockHasherMockRecorder struct {
        mock *MockHasher
}

// NewMockHasher creates a new mock instance.
func NewMockHasher(ctrl *gomock.Controller) *MockHasher <span class="cov1" title="1">{
        mock := &amp;MockHasher{ctrl: ctrl}
        mock.recorder = &amp;MockHasherMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockHasher) EXPECT() *MockHasherMockRecorder <span class="cov10" title="11">{
        return m.recorder
}</span>

// Compare mocks base method.
func (m *MockHasher) Compare(hash, password string) error <span class="cov7" title="5">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Compare", hash, password)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Compare indicates an expected call of Compare.
func (mr *MockHasherMockRecorder) Compare(hash, password interface{}) *gomock.Call <span class="cov7" title="5">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Compare", reflect.TypeOf((*MockHasher)(nil).Compare), hash, password)
}</span>

// Generate mocks base method.
func (m *MockHasher) Generate(password string) (string, error) <span class="cov7" title="6">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Generate", password)
        ret0, _ := ret[0].(string)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// Generate indicates an expected call of Generate.
func (mr *MockHasherMockRecorder) Generate(password interface{}) *gomock.Call <span class="cov7" title="6">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Generate", reflect.TypeOf((*MockHasher)(nil).Generate), password)
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: ./internal/repository/inventory_repository.go

// Package mocks is a generated GoMock package.
package mocks

import (
        context "context"
        reflect "reflect"

        gomock "github.com/golang/mock/gomock"
        db "github.com/myacey/avito-shop/db/sqlc"
)

// MockInventoryRepository is a mock of InventoryRepository interface.
type MockInventoryRepository struct {
        ctrl     *gomock.Controller
        recorder *MockInventoryRepositoryMockRecorder
}

// MockInventoryRepositoryMockRecorder is the mock recorder for MockInventoryRepository.
type MockInventoryRepositoryMockRecorder struct {
        mock *MockInventoryRepository
}

// NewMockInventoryRepository creates a new mock instance.
func NewMockInventoryRepository(ctrl *gomock.Controller) *MockInventoryRepository <span class="cov10" title="5">{
        mock := &amp;MockInventoryRepository{ctrl: ctrl}
        mock.recorder = &amp;MockInventoryRepositoryMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockInventoryRepository) EXPECT() *MockInventoryRepositoryMockRecorder <span class="cov10" title="5">{
        return m.recorder
}</span>

// AddItemToInventory mocks base method.
func (m *MockInventoryRepository) AddItemToInventory(c context.Context, userID int32, itemType string) error <span class="cov4" title="2">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "AddItemToInventory", c, userID, itemType)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// AddItemToInventory indicates an expected call of AddItemToInventory.
func (mr *MockInventoryRepositoryMockRecorder) AddItemToInventory(c, userID, itemType interface{}) *gomock.Call <span class="cov4" title="2">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AddItemToInventory", reflect.TypeOf((*MockInventoryRepository)(nil).AddItemToInventory), c, userID, itemType)
}</span>

// GetInventory mocks base method.
func (m *MockInventoryRepository) GetInventory(c context.Context, userID int32) ([]*db.Inventory, error) <span class="cov7" title="3">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetInventory", c, userID)
        ret0, _ := ret[0].([]*db.Inventory)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetInventory indicates an expected call of GetInventory.
func (mr *MockInventoryRepositoryMockRecorder) GetInventory(c, userID interface{}) *gomock.Call <span class="cov7" title="3">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetInventory", reflect.TypeOf((*MockInventoryRepository)(nil).GetInventory), c, userID)
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: ./internal/jwttoken/jwt.go

// Package mocks is a generated GoMock package.
package mocks

import (
        reflect "reflect"

        gomock "github.com/golang/mock/gomock"
)

// MockTokenMakerInterface is a mock of TokenMakerInterface interface.
type MockTokenMakerInterface struct {
        ctrl     *gomock.Controller
        recorder *MockTokenMakerInterfaceMockRecorder
}

// MockTokenMakerInterfaceMockRecorder is the mock recorder for MockTokenMakerInterface.
type MockTokenMakerInterfaceMockRecorder struct {
        mock *MockTokenMakerInterface
}

// NewMockTokenMakerInterface creates a new mock instance.
func NewMockTokenMakerInterface(ctrl *gomock.Controller) *MockTokenMakerInterface <span class="cov6" title="5">{
        mock := &amp;MockTokenMakerInterface{ctrl: ctrl}
        mock.recorder = &amp;MockTokenMakerInterfaceMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockTokenMakerInterface) EXPECT() *MockTokenMakerInterfaceMockRecorder <span class="cov10" title="13">{
        return m.recorder
}</span>

// CreateToken mocks base method.
func (m *MockTokenMakerInterface) CreateToken(username string) (string, error) <span class="cov7" title="6">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "CreateToken", username)
        ret0, _ := ret[0].(string)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// CreateToken indicates an expected call of CreateToken.
func (mr *MockTokenMakerInterfaceMockRecorder) CreateToken(username interface{}) *gomock.Call <span class="cov7" title="6">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateToken", reflect.TypeOf((*MockTokenMakerInterface)(nil).CreateToken), username)
}</span>

// VerifyToken mocks base method.
func (m *MockTokenMakerInterface) VerifyToken(tokenString string) (string, error) <span class="cov7" title="7">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "VerifyToken", tokenString)
        ret0, _ := ret[0].(string)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// VerifyToken indicates an expected call of VerifyToken.
func (mr *MockTokenMakerInterfaceMockRecorder) VerifyToken(tokenString interface{}) *gomock.Call <span class="cov7" title="7">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "VerifyToken", reflect.TypeOf((*MockTokenMakerInterface)(nil).VerifyToken), tokenString)
}</span>
</pre>
		
		<pre class="file" id="file10" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: db/sqlc/querier.go

// Package mocks is a generated GoMock package.
package mocks

import (
        context "context"
        reflect "reflect"

        gomock "github.com/golang/mock/gomock"
        db "github.com/myacey/avito-shop/db/sqlc"
)

// MockQuerier is a mock of Querier interface.
type MockQuerier struct {
        ctrl     *gomock.Controller
        recorder *MockQuerierMockRecorder
}

// MockQuerierMockRecorder is the mock recorder for MockQuerier.
type MockQuerierMockRecorder struct {
        mock *MockQuerier
}

// NewMockQuerier creates a new mock instance.
func NewMockQuerier(ctrl *gomock.Controller) *MockQuerier <span class="cov7" title="10">{
        mock := &amp;MockQuerier{ctrl: ctrl}
        mock.recorder = &amp;MockQuerierMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockQuerier) EXPECT() *MockQuerierMockRecorder <span class="cov10" title="28">{
        return m.recorder
}</span>

// BuyItem mocks base method.
func (m *MockQuerier) BuyItem(ctx context.Context, arg db.BuyItemParams) error <span class="cov2" title="2">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "BuyItem", ctx, arg)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// BuyItem indicates an expected call of BuyItem.
func (mr *MockQuerierMockRecorder) BuyItem(ctx, arg interface{}) *gomock.Call <span class="cov2" title="2">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "BuyItem", reflect.TypeOf((*MockQuerier)(nil).BuyItem), ctx, arg)
}</span>

// CreateMoneyTransfer mocks base method.
func (m *MockQuerier) CreateMoneyTransfer(ctx context.Context, arg db.CreateMoneyTransferParams) (db.Transfer, error) <span class="cov2" title="2">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "CreateMoneyTransfer", ctx, arg)
        ret0, _ := ret[0].(db.Transfer)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// CreateMoneyTransfer indicates an expected call of CreateMoneyTransfer.
func (mr *MockQuerierMockRecorder) CreateMoneyTransfer(ctx, arg interface{}) *gomock.Call <span class="cov2" title="2">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateMoneyTransfer", reflect.TypeOf((*MockQuerier)(nil).CreateMoneyTransfer), ctx, arg)
}</span>

// CreateUser mocks base method.
func (m *MockQuerier) CreateUser(ctx context.Context, arg db.CreateUserParams) (db.User, error) <span class="cov3" title="3">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "CreateUser", ctx, arg)
        ret0, _ := ret[0].(db.User)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// CreateUser indicates an expected call of CreateUser.
func (mr *MockQuerierMockRecorder) CreateUser(ctx, arg interface{}) *gomock.Call <span class="cov3" title="3">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateUser", reflect.TypeOf((*MockQuerier)(nil).CreateUser), ctx, arg)
}</span>

// GetInventory mocks base method.
func (m *MockQuerier) GetInventory(ctx context.Context, userID int32) ([]db.Inventory, error) <span class="cov3" title="3">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetInventory", ctx, userID)
        ret0, _ := ret[0].([]db.Inventory)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetInventory indicates an expected call of GetInventory.
func (mr *MockQuerierMockRecorder) GetInventory(ctx, userID interface{}) *gomock.Call <span class="cov3" title="3">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetInventory", reflect.TypeOf((*MockQuerier)(nil).GetInventory), ctx, userID)
}</span>

// GetItemFromStore mocks base method.
func (m *MockQuerier) GetItemFromStore(ctx context.Context, itemType string) (db.Item, error) <span class="cov3" title="3">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetItemFromStore", ctx, itemType)
        ret0, _ := ret[0].(db.Item)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetItemFromStore indicates an expected call of GetItemFromStore.
func (mr *MockQuerierMockRecorder) GetItemFromStore(ctx, itemType interface{}) *gomock.Call <span class="cov3" title="3">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetItemFromStore", reflect.TypeOf((*MockQuerier)(nil).GetItemFromStore), ctx, itemType)
}</span>

// GetTransfersWithUser mocks base method.
func (m *MockQuerier) GetTransfersWithUser(ctx context.Context, username string) ([]db.Transfer, error) <span class="cov3" title="3">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetTransfersWithUser", ctx, username)
        ret0, _ := ret[0].([]db.Transfer)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetTransfersWithUser indicates an expected call of GetTransfersWithUser.
func (mr *MockQuerierMockRecorder) GetTransfersWithUser(ctx, username interface{}) *gomock.Call <span class="cov3" title="3">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetTransfersWithUser", reflect.TypeOf((*MockQuerier)(nil).GetTransfersWithUser), ctx, username)
}</span>

// GetUser mocks base method.
func (m *MockQuerier) GetUser(ctx context.Context, username string) (db.User, error) <span class="cov3" title="3">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetUser", ctx, username)
        ret0, _ := ret[0].(db.User)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetUser indicates an expected call of GetUser.
func (mr *MockQuerierMockRecorder) GetUser(ctx, username interface{}) *gomock.Call <span class="cov3" title="3">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetUser", reflect.TypeOf((*MockQuerier)(nil).GetUser), ctx, username)
}</span>

// GetUserForUpdate mocks base method.
func (m *MockQuerier) GetUserForUpdate(ctx context.Context, username string) (db.User, error) <span class="cov3" title="3">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetUserForUpdate", ctx, username)
        ret0, _ := ret[0].(db.User)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetUserForUpdate indicates an expected call of GetUserForUpdate.
func (mr *MockQuerierMockRecorder) GetUserForUpdate(ctx, username interface{}) *gomock.Call <span class="cov3" title="3">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetUserForUpdate", reflect.TypeOf((*MockQuerier)(nil).GetUserForUpdate), ctx, username)
}</span>

// GetUserViaID mocks base method.
func (m *MockQuerier) GetUserViaID(ctx context.Context, userID int32) (db.User, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetUserViaID", ctx, userID)
        ret0, _ := ret[0].(db.User)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetUserViaID indicates an expected call of GetUserViaID.
func (mr *MockQuerierMockRecorder) GetUserViaID(ctx, userID interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetUserViaID", reflect.TypeOf((*MockQuerier)(nil).GetUserViaID), ctx, userID)
}</span>

// UpdateTwoUsersBalance mocks base method.
func (m *MockQuerier) UpdateTwoUsersBalance(ctx context.Context, arg db.UpdateTwoUsersBalanceParams) ([]db.User, error) <span class="cov3" title="3">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "UpdateTwoUsersBalance", ctx, arg)
        ret0, _ := ret[0].([]db.User)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// UpdateTwoUsersBalance indicates an expected call of UpdateTwoUsersBalance.
func (mr *MockQuerierMockRecorder) UpdateTwoUsersBalance(ctx, arg interface{}) *gomock.Call <span class="cov3" title="3">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateTwoUsersBalance", reflect.TypeOf((*MockQuerier)(nil).UpdateTwoUsersBalance), ctx, arg)
}</span>

// UpdateUserBalance mocks base method.
func (m *MockQuerier) UpdateUserBalance(ctx context.Context, arg db.UpdateUserBalanceParams) (db.User, error) <span class="cov3" title="3">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "UpdateUserBalance", ctx, arg)
        ret0, _ := ret[0].(db.User)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// UpdateUserBalance indicates an expected call of UpdateUserBalance.
func (mr *MockQuerierMockRecorder) UpdateUserBalance(ctx, arg interface{}) *gomock.Call <span class="cov3" title="3">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateUserBalance", reflect.TypeOf((*MockQuerier)(nil).UpdateUserBalance), ctx, arg)
}</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: ./internal/service/service.go

// Package mocks is a generated GoMock package.
package mocks

import (
        context "context"
        reflect "reflect"

        gomock "github.com/golang/mock/gomock"
        models "github.com/myacey/avito-shop/internal/models"
)

// MockInterface is a mock of Interface interface.
type MockInterface struct {
        ctrl     *gomock.Controller
        recorder *MockInterfaceMockRecorder
}

// MockInterfaceMockRecorder is the mock recorder for MockInterface.
type MockInterfaceMockRecorder struct {
        mock *MockInterface
}

// NewMockInterface creates a new mock instance.
func NewMockInterface(ctrl *gomock.Controller) *MockInterface <span class="cov7" title="4">{
        mock := &amp;MockInterface{ctrl: ctrl}
        mock.recorder = &amp;MockInterfaceMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockInterface) EXPECT() *MockInterfaceMockRecorder <span class="cov10" title="8">{
        return m.recorder
}</span>

// AuthorizeUser mocks base method.
func (m *MockInterface) AuthorizeUser(c context.Context, username, password string) (string, error) <span class="cov4" title="2">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "AuthorizeUser", c, username, password)
        ret0, _ := ret[0].(string)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// AuthorizeUser indicates an expected call of AuthorizeUser.
func (mr *MockInterfaceMockRecorder) AuthorizeUser(c, username, password interface{}) *gomock.Call <span class="cov4" title="2">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AuthorizeUser", reflect.TypeOf((*MockInterface)(nil).AuthorizeUser), c, username, password)
}</span>

// BuyItem mocks base method.
func (m *MockInterface) BuyItem(c context.Context, username, itemName string) error <span class="cov4" title="2">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "BuyItem", c, username, itemName)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// BuyItem indicates an expected call of BuyItem.
func (mr *MockInterfaceMockRecorder) BuyItem(c, username, itemName interface{}) *gomock.Call <span class="cov4" title="2">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "BuyItem", reflect.TypeOf((*MockInterface)(nil).BuyItem), c, username, itemName)
}</span>

// CheckAuthToken mocks base method.
func (m *MockInterface) CheckAuthToken(c context.Context, token string) (string, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "CheckAuthToken", c, token)
        ret0, _ := ret[0].(string)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// CheckAuthToken indicates an expected call of CheckAuthToken.
func (mr *MockInterfaceMockRecorder) CheckAuthToken(c, token interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CheckAuthToken", reflect.TypeOf((*MockInterface)(nil).CheckAuthToken), c, token)
}</span>

// GetFullUserInfo mocks base method.
func (m *MockInterface) GetFullUserInfo(c context.Context, username string) (*models.User, error) <span class="cov4" title="2">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetFullUserInfo", c, username)
        ret0, _ := ret[0].(*models.User)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetFullUserInfo indicates an expected call of GetFullUserInfo.
func (mr *MockInterfaceMockRecorder) GetFullUserInfo(c, username interface{}) *gomock.Call <span class="cov4" title="2">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetFullUserInfo", reflect.TypeOf((*MockInterface)(nil).GetFullUserInfo), c, username)
}</span>

// SendCoin mocks base method.
func (m *MockInterface) SendCoin(c context.Context, fromUsername, toUsername string, amount int32) error <span class="cov4" title="2">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "SendCoin", c, fromUsername, toUsername, amount)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// SendCoin indicates an expected call of SendCoin.
func (mr *MockInterfaceMockRecorder) SendCoin(c, fromUsername, toUsername, amount interface{}) *gomock.Call <span class="cov4" title="2">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SendCoin", reflect.TypeOf((*MockInterface)(nil).SendCoin), c, fromUsername, toUsername, amount)
}</span>
</pre>
		
		<pre class="file" id="file12" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: ./internal/repository/session_repository.go

// Package mocks is a generated GoMock package.
package mocks

import (
        context "context"
        reflect "reflect"
        time "time"

        gomock "github.com/golang/mock/gomock"
)

// MockSessionRepository is a mock of SessionRepository interface.
type MockSessionRepository struct {
        ctrl     *gomock.Controller
        recorder *MockSessionRepositoryMockRecorder
}

// MockSessionRepositoryMockRecorder is the mock recorder for MockSessionRepository.
type MockSessionRepositoryMockRecorder struct {
        mock *MockSessionRepository
}

// NewMockSessionRepository creates a new mock instance.
func NewMockSessionRepository(ctrl *gomock.Controller) *MockSessionRepository <span class="cov7" title="5">{
        mock := &amp;MockSessionRepository{ctrl: ctrl}
        mock.recorder = &amp;MockSessionRepositoryMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockSessionRepository) EXPECT() *MockSessionRepositoryMockRecorder <span class="cov10" title="8">{
        return m.recorder
}</span>

// CreateToken mocks base method.
func (m *MockSessionRepository) CreateToken(c context.Context, key, value string, ttl time.Duration) error <span class="cov7" title="4">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "CreateToken", c, key, value, ttl)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// CreateToken indicates an expected call of CreateToken.
func (mr *MockSessionRepositoryMockRecorder) CreateToken(c, key, value, ttl interface{}) *gomock.Call <span class="cov7" title="4">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateToken", reflect.TypeOf((*MockSessionRepository)(nil).CreateToken), c, key, value, ttl)
}</span>

// GetToken mocks base method.
func (m *MockSessionRepository) GetToken(c context.Context, key string) (string, error) <span class="cov7" title="4">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetToken", c, key)
        ret0, _ := ret[0].(string)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetToken indicates an expected call of GetToken.
func (mr *MockSessionRepositoryMockRecorder) GetToken(c, key interface{}) *gomock.Call <span class="cov7" title="4">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetToken", reflect.TypeOf((*MockSessionRepository)(nil).GetToken), c, key)
}</span>
</pre>
		
		<pre class="file" id="file13" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: ./internal/repository/store_repository.go

// Package mocks is a generated GoMock package.
package mocks

import (
        context "context"
        reflect "reflect"

        gomock "github.com/golang/mock/gomock"
        db "github.com/myacey/avito-shop/db/sqlc"
)

// MockStoreRepository is a mock of StoreRepository interface.
type MockStoreRepository struct {
        ctrl     *gomock.Controller
        recorder *MockStoreRepositoryMockRecorder
}

// MockStoreRepositoryMockRecorder is the mock recorder for MockStoreRepository.
type MockStoreRepositoryMockRecorder struct {
        mock *MockStoreRepository
}

// NewMockStoreRepository creates a new mock instance.
func NewMockStoreRepository(ctrl *gomock.Controller) *MockStoreRepository <span class="cov7" title="5">{
        mock := &amp;MockStoreRepository{ctrl: ctrl}
        mock.recorder = &amp;MockStoreRepositoryMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockStoreRepository) EXPECT() *MockStoreRepositoryMockRecorder <span class="cov10" title="9">{
        return m.recorder
}</span>

// GetItemInfo mocks base method.
func (m *MockStoreRepository) GetItemInfo(c context.Context, itemName string) (*db.Item, error) <span class="cov10" title="9">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetItemInfo", c, itemName)
        ret0, _ := ret[0].(*db.Item)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetItemInfo indicates an expected call of GetItemInfo.
func (mr *MockStoreRepositoryMockRecorder) GetItemInfo(c, itemName interface{}) *gomock.Call <span class="cov10" title="9">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetItemInfo", reflect.TypeOf((*MockStoreRepository)(nil).GetItemInfo), c, itemName)
}</span>
</pre>
		
		<pre class="file" id="file14" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: internal/repository/transfer_repository.go

// Package mocks is a generated GoMock package.
package mocks

import (
        context "context"
        reflect "reflect"

        gomock "github.com/golang/mock/gomock"
        db "github.com/myacey/avito-shop/db/sqlc"
)

// MockTransferRepository is a mock of TransferRepository interface.
type MockTransferRepository struct {
        ctrl     *gomock.Controller
        recorder *MockTransferRepositoryMockRecorder
}

// MockTransferRepositoryMockRecorder is the mock recorder for MockTransferRepository.
type MockTransferRepositoryMockRecorder struct {
        mock *MockTransferRepository
}

// NewMockTransferRepository creates a new mock instance.
func NewMockTransferRepository(ctrl *gomock.Controller) *MockTransferRepository <span class="cov10" title="5">{
        mock := &amp;MockTransferRepository{ctrl: ctrl}
        mock.recorder = &amp;MockTransferRepositoryMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockTransferRepository) EXPECT() *MockTransferRepositoryMockRecorder <span class="cov8" title="4">{
        return m.recorder
}</span>

// CreateMoneyTransfer mocks base method.
func (m *MockTransferRepository) CreateMoneyTransfer(c context.Context, fromUsername, toUsername string, amount int32) (*db.Transfer, error) <span class="cov4" title="2">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "CreateMoneyTransfer", c, fromUsername, toUsername, amount)
        ret0, _ := ret[0].(*db.Transfer)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// CreateMoneyTransfer indicates an expected call of CreateMoneyTransfer.
func (mr *MockTransferRepositoryMockRecorder) CreateMoneyTransfer(c, fromUsername, toUsername, amount interface{}) *gomock.Call <span class="cov4" title="2">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateMoneyTransfer", reflect.TypeOf((*MockTransferRepository)(nil).CreateMoneyTransfer), c, fromUsername, toUsername, amount)
}</span>

// GetTransfersWithUser mocks base method.
func (m *MockTransferRepository) GetTransfersWithUser(c context.Context, username string) ([]*db.Transfer, error) <span class="cov4" title="2">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetTransfersWithUser", c, username)
        ret0, _ := ret[0].([]*db.Transfer)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetTransfersWithUser indicates an expected call of GetTransfersWithUser.
func (mr *MockTransferRepositoryMockRecorder) GetTransfersWithUser(c, username interface{}) *gomock.Call <span class="cov4" title="2">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetTransfersWithUser", reflect.TypeOf((*MockTransferRepository)(nil).GetTransfersWithUser), c, username)
}</span>
</pre>
		
		<pre class="file" id="file15" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: ./internal/repository/user_repository.go

// Package mocks is a generated GoMock package.
package mocks

import (
        context "context"
        reflect "reflect"

        gomock "github.com/golang/mock/gomock"
        db "github.com/myacey/avito-shop/db/sqlc"
)

// MockUserRepository is a mock of UserRepository interface.
type MockUserRepository struct {
        ctrl     *gomock.Controller
        recorder *MockUserRepositoryMockRecorder
}

// MockUserRepositoryMockRecorder is the mock recorder for MockUserRepository.
type MockUserRepositoryMockRecorder struct {
        mock *MockUserRepository
}

// NewMockUserRepository creates a new mock instance.
func NewMockUserRepository(ctrl *gomock.Controller) *MockUserRepository <span class="cov5" title="5">{
        mock := &amp;MockUserRepository{ctrl: ctrl}
        mock.recorder = &amp;MockUserRepositoryMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockUserRepository) EXPECT() *MockUserRepositoryMockRecorder <span class="cov10" title="34">{
        return m.recorder
}</span>

// CreateUser mocks base method.
func (m *MockUserRepository) CreateUser(c context.Context, username, password string) (*db.User, error) <span class="cov4" title="4">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "CreateUser", c, username, password)
        ret0, _ := ret[0].(*db.User)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// CreateUser indicates an expected call of CreateUser.
func (mr *MockUserRepositoryMockRecorder) CreateUser(c, username, password interface{}) *gomock.Call <span class="cov4" title="4">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateUser", reflect.TypeOf((*MockUserRepository)(nil).CreateUser), c, username, password)
}</span>

// GetUser mocks base method.
func (m *MockUserRepository) GetUser(c context.Context, username string) (*db.User, error) <span class="cov8" title="17">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetUser", c, username)
        ret0, _ := ret[0].(*db.User)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetUser indicates an expected call of GetUser.
func (mr *MockUserRepositoryMockRecorder) GetUser(c, username interface{}) *gomock.Call <span class="cov8" title="17">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetUser", reflect.TypeOf((*MockUserRepository)(nil).GetUser), c, username)
}</span>

// GetUserForUpdate mocks base method.
func (m *MockUserRepository) GetUserForUpdate(c context.Context, username string) (*db.User, error) <span class="cov5" title="6">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetUserForUpdate", c, username)
        ret0, _ := ret[0].(*db.User)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetUserForUpdate indicates an expected call of GetUserForUpdate.
func (mr *MockUserRepositoryMockRecorder) GetUserForUpdate(c, username interface{}) *gomock.Call <span class="cov5" title="6">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetUserForUpdate", reflect.TypeOf((*MockUserRepository)(nil).GetUserForUpdate), c, username)
}</span>

// UpdateBalance mocks base method.
func (m *MockUserRepository) UpdateBalance(c context.Context, userID, newCointCount int32) (*db.User, error) <span class="cov3" title="3">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "UpdateBalance", c, userID, newCointCount)
        ret0, _ := ret[0].(*db.User)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// UpdateBalance indicates an expected call of UpdateBalance.
func (mr *MockUserRepositoryMockRecorder) UpdateBalance(c, userID, newCointCount interface{}) *gomock.Call <span class="cov3" title="3">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateBalance", reflect.TypeOf((*MockUserRepository)(nil).UpdateBalance), c, userID, newCointCount)
}</span>

// UpdateTwoUsersBalance mocks base method.
func (m *MockUserRepository) UpdateTwoUsersBalance(c context.Context, fromUsername, toUsername string, coinsAmount int32) ([]*db.User, error) <span class="cov4" title="4">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "UpdateTwoUsersBalance", c, fromUsername, toUsername, coinsAmount)
        ret0, _ := ret[0].([]*db.User)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// UpdateTwoUsersBalance indicates an expected call of UpdateTwoUsersBalance.
func (mr *MockUserRepositoryMockRecorder) UpdateTwoUsersBalance(c, fromUsername, toUsername, coinsAmount interface{}) *gomock.Call <span class="cov4" title="4">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateTwoUsersBalance", reflect.TypeOf((*MockUserRepository)(nil).UpdateTwoUsersBalance), c, fromUsername, toUsername, coinsAmount)
}</span>
</pre>
		
		<pre class="file" id="file16" style="display: none">package postgresrepo

import (
        "context"
        "database/sql"
        "errors"

        db "github.com/myacey/avito-shop/db/sqlc"
        "github.com/myacey/avito-shop/internal/repository"
)

type PostgresInventoryRepo struct {
        store db.Querier
}

func NewPostgresInventoryRepo(store db.Querier) repository.InventoryRepository <span class="cov6" title="2">{
        return &amp;PostgresInventoryRepo{store}
}</span>

func (r *PostgresInventoryRepo) AddItemToInventory(c context.Context, userID int32, itemType string) error <span class="cov6" title="2">{
        arg := db.BuyItemParams{
                UserID:   userID,
                ItemType: itemType,
        }
        err := r.store.BuyItem(c, arg)
        if err != nil </span><span class="cov1" title="1">{
                return err
        }</span>

        <span class="cov1" title="1">return nil</span>
}

func (r *PostgresInventoryRepo) GetInventory(c context.Context, userID int32) ([]*db.Inventory, error) <span class="cov10" title="3">{
        inv, err := r.store.GetInventory(c, userID)
        if err != nil </span><span class="cov6" title="2">{
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov1" title="1">{
                        return nil, repository.ErrNoInventoryItems
                }</span>
                <span class="cov1" title="1">return nil, err</span>
        }

        <span class="cov1" title="1">ans := make([]*db.Inventory, len(inv))
        for i := range inv </span><span class="cov6" title="2">{
                ans[i] = &amp;inv[i]
        }</span>

        <span class="cov1" title="1">return ans, nil</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package postgresrepo

import (
        "database/sql"
        "fmt"

        "github.com/lib/pq"
        db "github.com/myacey/avito-shop/db/sqlc"
        "github.com/myacey/avito-shop/internal/backconfig"
)

func ConfiurePostgres(config backconfig.Config) (*db.Queries, *sql.DB, error) <span class="cov0" title="0">{
        psqlInfo := fmt.Sprintf("host=%s port=%s user=%s "+
                "password=%s dbname=%s sslmode=disable",
                config.PostgresHost, config.PostgresPort, config.PostgresUser,
                config.DBPassword, config.PostgresDBName)

        conn, err := sql.Open("postgres", psqlInfo)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("canot open postgres conn: %w", err)
        }</span>
        <span class="cov0" title="0">err = conn.Ping()
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("cannot ping postgres: %w", err)
        }</span>

        <span class="cov0" title="0">queries := db.New(conn)

        return queries, conn, nil</span>
}

// isUniqueViolation checks if err is about
// not unique val.
func isUniqueViolation(err error) bool <span class="cov10" title="2">{
        if pqErr, ok := err.(*pq.Error); ok </span><span class="cov1" title="1">{
                return pqErr.Code == "23505"
        }</span>
        <span class="cov1" title="1">return false</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package postgresrepo

import (
        "context"
        "database/sql"
        "errors"

        db "github.com/myacey/avito-shop/db/sqlc"
        "github.com/myacey/avito-shop/internal/repository"
)

type PostgresStoreRepo struct {
        store db.Querier
}

func NewPostgresStoreRepo(store db.Querier) repository.StoreRepository <span class="cov1" title="1">{
        return &amp;PostgresStoreRepo{store}
}</span>

func (r *PostgresStoreRepo) GetItemInfo(c context.Context, itemName string) (*db.Item, error) <span class="cov10" title="3">{
        item, err := r.store.GetItemFromStore(c, itemName)
        if err != nil </span><span class="cov6" title="2">{
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov1" title="1">{
                        return nil, repository.ErrInvalidItemName
                }</span>
                <span class="cov1" title="1">return nil, err</span>
        }

        <span class="cov1" title="1">return &amp;item, nil</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package postgresrepo

import (
        "context"
        "database/sql"
        "errors"

        db "github.com/myacey/avito-shop/db/sqlc"
        "github.com/myacey/avito-shop/internal/repository"
)

type PostgresTransferRepo struct {
        store db.Querier
}

func NewPostgresTransferRepo(store db.Querier) repository.TransferRepository <span class="cov6" title="2">{
        return &amp;PostgresTransferRepo{store}
}</span>

func (r *PostgresTransferRepo) CreateMoneyTransfer(c context.Context, fromUsername, toUsername string, amount int32) (*db.Transfer, error) <span class="cov6" title="2">{
        arg := db.CreateMoneyTransferParams{
                FromUsername: fromUsername,
                ToUsername:   toUsername,
                Amount:       amount,
        }

        transfer, err := r.store.CreateMoneyTransfer(c, arg)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov1" title="1">return &amp;transfer, nil</span>
}

func (r *PostgresTransferRepo) GetTransfersWithUser(c context.Context, username string) ([]*db.Transfer, error) <span class="cov10" title="3">{
        transfers, err := r.store.GetTransfersWithUser(c, username)
        if err != nil </span><span class="cov6" title="2">{
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov1" title="1">{
                        return nil, repository.ErrNoTransfers
                }</span>
                <span class="cov1" title="1">return nil, err</span>
        }

        <span class="cov1" title="1">ans := make([]*db.Transfer, len(transfers))
        for i := range transfers </span><span class="cov6" title="2">{
                ans[i] = &amp;transfers[i]
        }</span>

        <span class="cov1" title="1">return ans, nil</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package postgresrepo

import (
        "context"
        "database/sql"
        "errors"

        db "github.com/myacey/avito-shop/db/sqlc"
        "github.com/myacey/avito-shop/internal/repository"
)

type PostgresUserRepo struct {
        store db.Querier
}

func NewPostgresUserRepo(store db.Querier) repository.UserRepository <span class="cov10" title="5">{
        return &amp;PostgresUserRepo{
                store: store,
        }
}</span>

func (r *PostgresUserRepo) CreateUser(c context.Context, username, password string) (*db.User, error) <span class="cov7" title="3">{
        arg := db.CreateUserParams{
                Username: username,
                Password: password,
        }
        usr, err := r.store.CreateUser(c, arg)
        if err != nil </span><span class="cov4" title="2">{
                if isUniqueViolation(err) </span><span class="cov1" title="1">{
                        return nil, repository.ErrUserAlreadyExists
                }</span>
                <span class="cov1" title="1">return nil, err</span>
        }

        <span class="cov1" title="1">return &amp;usr, nil</span>
}

func (r *PostgresUserRepo) GetUser(c context.Context, username string) (*db.User, error) <span class="cov7" title="3">{
        usr, err := r.store.GetUser(c, username)
        if err != nil </span><span class="cov4" title="2">{
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov1" title="1">{
                        return nil, repository.ErrUserNotFound
                }</span>
                <span class="cov1" title="1">return nil, err</span>
        }

        <span class="cov1" title="1">return &amp;usr, nil</span>
}

// Should be called only in transactions.
func (r *PostgresUserRepo) GetUserForUpdate(c context.Context, username string) (*db.User, error) <span class="cov7" title="3">{
        usr, err := r.store.GetUserForUpdate(c, username)
        if err != nil </span><span class="cov4" title="2">{
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov1" title="1">{
                        return nil, repository.ErrUserNotFound
                }</span>
                <span class="cov1" title="1">return nil, err</span>
        }

        <span class="cov1" title="1">return &amp;usr, nil</span>
}

func (r *PostgresUserRepo) UpdateBalance(c context.Context, userID int32, newCointCount int32) (*db.User, error) <span class="cov7" title="3">{
        arg := db.UpdateUserBalanceParams{
                UserID: userID,
                Coins:  newCointCount,
        }

        usr, err := r.store.UpdateUserBalance(c, arg)
        if err != nil </span><span class="cov4" title="2">{
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov1" title="1">{
                        return nil, repository.ErrUserNotFound
                }</span>
                <span class="cov1" title="1">return nil, err</span>
        }

        <span class="cov1" title="1">return &amp;usr, nil</span>
}

func (r *PostgresUserRepo) UpdateTwoUsersBalance(c context.Context, fromUsername, toUsername string, coinsAmount int32) ([]*db.User, error) <span class="cov7" title="3">{
        usrs, err := r.store.UpdateTwoUsersBalance(c, db.UpdateTwoUsersBalanceParams{
                FromUsername: fromUsername,
                ToUsername:   toUsername,
                Coins:        coinsAmount,
        })
        if err != nil </span><span class="cov4" title="2">{
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov1" title="1">{
                        return nil, repository.ErrUserNotFound
                }</span>
                <span class="cov1" title="1">return nil, err</span>
        }

        <span class="cov1" title="1">ans := make([]*db.User, len(usrs))
        for i := range usrs </span><span class="cov4" title="2">{
                ans[i] = &amp;usrs[i]
        }</span>

        <span class="cov1" title="1">return ans, nil</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package redisrepo

import (
        "context"
        "time"

        "github.com/myacey/avito-shop/internal/backconfig"
        "github.com/redis/go-redis/v9"
)

func ConfigureRedisClient(config *backconfig.Config) (*redis.Client, error) <span class="cov0" title="0">{
        rdb := redis.NewClient(&amp;redis.Options{
                Addr:     config.RedisHost + ":6379",
                Password: "",
                DB:       0,

                PoolSize:        1300,
                MinIdleConns:    550,
                MaxIdleConns:    1000,
                ConnMaxIdleTime: 30 * time.Minute,
        })

        if err := rdb.Ping(context.Background()).Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return rdb, nil</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">package redisrepo

import (
        "context"
        "errors"
        "time"

        "github.com/myacey/avito-shop/internal/repository"
        "github.com/redis/go-redis/v9"
)

type RedisSessionRepository struct {
        rdb *redis.Client
}

func NewRedisSessionRepo(rdb *redis.Client) repository.SessionRepository <span class="cov0" title="0">{
        return &amp;RedisSessionRepository{rdb}
}</span>

func (r *RedisSessionRepository) GetToken(c context.Context, key string) (string, error) <span class="cov0" title="0">{
        tok, err := r.rdb.Get(c, key).Result()
        if errors.Is(err, redis.Nil) </span><span class="cov0" title="0">{
                return "", repository.ErrTokenNotFound
        }</span>

        <span class="cov0" title="0">return tok, err</span>
}

func (r *RedisSessionRepository) CreateToken(c context.Context, key, value string, ttl time.Duration) error <span class="cov0" title="0">{
        return r.rdb.Set(c, key, value, ttl).Err()
}</span>
</pre>
		
		<pre class="file" id="file23" style="display: none">package service

import (
        "context"
        "database/sql"
        "errors"
        "fmt"
        "time"

        "github.com/myacey/avito-shop/internal/apperror"
        "github.com/myacey/avito-shop/internal/hasher"
        "github.com/myacey/avito-shop/internal/jwttoken"
        "github.com/myacey/avito-shop/internal/models"
        "github.com/myacey/avito-shop/internal/repository"
)

var (
        ErrInvalidPassword = errors.New("invalid password")
        ErrNotEnoughMoney  = errors.New("not enough money on account")
        ErrInvalidToken    = errors.New("invalid auth token")
)

const sessionKeyTTL = time.Duration(24 * time.Hour)

type Interface interface {
        // /api/auth
        AuthorizeUser(c context.Context, username, password string) (string, error)

        CheckAuthToken(c context.Context, token string) (string, error)

        // /api/info
        GetFullUserInfo(c context.Context, username string) (*models.User, error)

        // /api/sendCoin
        SendCoin(c context.Context, fromUsername string, toUsername string, amount int32) error

        // /api/buy/{item}
        BuyItem(c context.Context, username string, itemName string) error
}

type Service struct {
        dbConn *sql.DB

        userRepo      repository.UserRepository
        transferRepo  repository.TransferRepository
        inventoryRepo repository.InventoryRepository
        storeRepo     repository.StoreRepository

        tokenMaker  jwttoken.TokenMakerInterface
        sessionRepo repository.SessionRepository

        hasher hasher.Hasher
}

func NewService(
        dbConn *sql.DB,
        ur repository.UserRepository,
        tr repository.TransferRepository,
        ir repository.InventoryRepository,
        sr repository.StoreRepository,
        rsr repository.SessionRepository,
        tokMaker jwttoken.TokenMakerInterface,
        hasher hasher.Hasher,
) Interface <span class="cov6" title="5">{
        return &amp;Service{
                dbConn:        dbConn,
                userRepo:      ur,
                transferRepo:  tr,
                inventoryRepo: ir,
                storeRepo:     sr,
                sessionRepo:   rsr,
                tokenMaker:    tokMaker,
                hasher:        hasher,
        }
}</span>

func (s *Service) createUser(c context.Context, username, password string) (string, error) <span class="cov7" title="6">{
        hashedPassword, err := s.hasher.Generate(password)
        if err != nil </span><span class="cov3" title="2">{
                if errors.Is(err, hasher.ErrToLong) </span><span class="cov1" title="1">{
                        return "", apperror.NewBadReq("password too long", err)
                }</span>
                <span class="cov1" title="1">return "", apperror.NewInternal("failed to generate password hash", err)</span>
        }

        <span class="cov6" title="4">_, err = s.userRepo.CreateUser(c, username, string(hashedPassword))
        if err != nil </span><span class="cov1" title="1">{
                return "", apperror.NewInternal("failed to create user", err)
        }</span>

        // create auth token
        <span class="cov4" title="3">token, err := s.tokenMaker.CreateToken(username)
        if err != nil </span><span class="cov1" title="1">{
                return "", apperror.NewInternal("failed to create token for user", err)
        }</span>

        <span class="cov3" title="2">if err = s.sessionRepo.CreateToken(c, username, token, sessionKeyTTL); err != nil </span><span class="cov1" title="1">{
                return "", apperror.NewInternal("failed to save token", err)
        }</span>
        <span class="cov1" title="1">return token, nil</span>
}

// Authorization checks user credentials, creates new dbUser if needed.
func (s *Service) AuthorizeUser(c context.Context, username, password string) (string, error) <span class="cov10" title="12">{
        dbUsr, err := s.userRepo.GetUser(c, username)

        // unknown error
        if err != nil &amp;&amp; !errors.Is(err, repository.ErrUserNotFound) </span><span class="cov1" title="1">{
                return "", apperror.NewInternal("failed to get user", err)
        }</span>

        // user dont exists -&gt; generate new one
        <span class="cov9" title="11">if errors.Is(err, repository.ErrUserNotFound) </span><span class="cov7" title="6">{
                return s.createUser(c, username, password)
        }</span>

        // User found, check him
        // check password
        <span class="cov6" title="5">if err = s.hasher.Compare(dbUsr.Password, password); err != nil </span><span class="cov3" title="2">{
                if errors.Is(err, hasher.ErrDontCompare) </span><span class="cov1" title="1">{
                        return "", apperror.NewNotFound("user not found", err)
                }</span>
                <span class="cov1" title="1">return "", apperror.NewInternal("failed to compare passwords", err)</span>
        }

        // generate token
        <span class="cov4" title="3">newToken, err := s.tokenMaker.CreateToken(username)
        if err != nil </span><span class="cov1" title="1">{
                return "", apperror.NewInternal("failed to create token", err)
        }</span>

        // save token
        <span class="cov3" title="2">if err = s.sessionRepo.CreateToken(c, username, newToken, sessionKeyTTL); err != nil </span><span class="cov1" title="1">{
                return "", apperror.NewInternal("failed to save token", err)
        }</span>

        <span class="cov1" title="1">return newToken, nil</span>
}

// CheckAuthToken extracts username from jwt payload, gets a dbToken
// from redis and checks if providen "token==dbToken".
func (s *Service) CheckAuthToken(c context.Context, token string) (string, error) <span class="cov8" title="7">{
        username, err := s.tokenMaker.VerifyToken(token)
        if err != nil </span><span class="cov4" title="3">{
                switch </span>{
                case errors.Is(err, jwttoken.ErrInvalidKey):<span class="cov1" title="1">
                        return "", apperror.NewUnauthorized(jwttoken.ErrInvalidKey.Error(), nil)</span>
                case errors.Is(err, jwttoken.ErrTokenExpired):<span class="cov1" title="1">
                        return "", apperror.NewUnauthorized(jwttoken.ErrTokenExpired.Error(), nil)</span>
                default:<span class="cov1" title="1">
                        return "", apperror.NewInternal("failed to verify token", err)</span>
                }
        }

        <span class="cov6" title="4">dbToken, err := s.sessionRepo.GetToken(c, username)
        if err != nil </span><span class="cov3" title="2">{
                if errors.Is(err, repository.ErrTokenNotFound) </span><span class="cov1" title="1">{
                        return "", apperror.NewUnauthorized("invalid token", err)
                }</span>
                <span class="cov1" title="1">return "", apperror.NewInternal("failed to find token", err)</span>
        }

        <span class="cov3" title="2">if dbToken != token </span><span class="cov1" title="1">{
                return "", apperror.NewUnauthorized("invalid token", ErrInvalidToken)
        }</span>

        <span class="cov1" title="1">return username, nil</span>
}

type IncomeEntry struct {
        FromUser string `json:"fromUser"`
        Amount   int32  `json:"amount"`
}

type OutcomeEntry struct {
        ToUser string `json:"toUser"`
        Amount int32  `json:"amount"`
}

// fillInventory is helper func to fill user's inventory.
// returns apperror.
func (s *Service) fillInventory(c context.Context, usr *models.User, userID int32) error <span class="cov4" title="3">{
        inventory, err := s.inventoryRepo.GetInventory(c, userID)
        if err != nil &amp;&amp; !errors.Is(err, repository.ErrNoInventoryItems) </span><span class="cov1" title="1">{
                return apperror.NewInternal("failed to get user inventory", err)
        }</span>

        // fill inventory
        <span class="cov3" title="2">usr.Inventory = make([]*models.InventoryItem, len(inventory))
        for i, v := range inventory </span><span class="cov6" title="4">{
                usr.Inventory[i] = &amp;models.InventoryItem{
                        Type:     v.ItemType,
                        Quantity: v.Quantity,
                }
        }</span>

        <span class="cov3" title="2">return nil</span>
}

// fillEntries is helper func to fill user's entries list (recoieved, send entries).
// returns apperror.
func (s *Service) fillEntries(c context.Context, usr *models.User, username string) error <span class="cov3" title="2">{
        // fill entries
        entries, err := s.transferRepo.GetTransfersWithUser(c, username)
        if err != nil &amp;&amp; !errors.Is(err, repository.ErrNoTransfers) </span><span class="cov1" title="1">{
                return apperror.NewInternal("failed to find transactions", err)
        }</span>

        <span class="cov1" title="1">m := map[string]interface{}{}
        income := make([]*IncomeEntry, 0, len(entries))
        outcome := make([]*OutcomeEntry, 0, len(entries))
        for _, v := range entries </span><span class="cov3" title="2">{
                if v.ToUsername == username </span><span class="cov1" title="1">{
                        income = append(income, &amp;IncomeEntry{FromUser: v.FromUsername, Amount: v.Amount})
                }</span> else<span class="cov1" title="1"> if v.FromUsername == username </span><span class="cov1" title="1">{
                        outcome = append(outcome, &amp;OutcomeEntry{ToUser: v.ToUsername, Amount: v.Amount})
                }</span>
        }
        <span class="cov1" title="1">m["received"] = income
        m["sent"] = outcome
        usr.EntryHistory = m

        return nil</span>
}

// GetFullUserInfo fetchs main usr info, transaction hisotry and items in inventory.
func (s *Service) GetFullUserInfo(c context.Context, username string) (*models.User, error) <span class="cov6" title="5">{
        dbUsr, err := s.userRepo.GetUser(c, username)
        if err != nil </span><span class="cov3" title="2">{
                if errors.Is(err, repository.ErrUserNotFound) </span><span class="cov1" title="1">{
                        return nil, apperror.NewNotFound("user not found", err)
                }</span>
                <span class="cov1" title="1">return nil, apperror.NewInternal("failed to get user", err)</span>
        }

        <span class="cov4" title="3">usr := &amp;models.User{
                ID:           dbUsr.UserID,
                Username:     dbUsr.Username,
                Coins:        dbUsr.Coins,
                Inventory:    nil,
                EntryHistory: nil,
        }

        if err = s.fillInventory(c, usr, dbUsr.UserID); err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov3" title="2">if err = s.fillEntries(c, usr, username); err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov1" title="1">return usr, nil</span>
}

// SendCoins runs a transacion to create new transaction and update user's coins.
func (s *Service) SendCoin(c context.Context, fromUsername string, toUsername string, amount int32) error <span class="cov7" title="6">{
        if amount &lt;= 0 </span><span class="cov1" title="1">{
                return apperror.NewBadReq("send coins amont must be positive", nil)
        }</span>

        <span class="cov6" title="5">tx, err := s.dbConn.BeginTx(c, nil)
        if err != nil </span><span class="cov1" title="1">{
                return apperror.NewInternal("failed to send coins", err)
        }</span>
        <span class="cov6" title="4">defer tx.Rollback()

        _, err = s.userRepo.UpdateTwoUsersBalance(c, fromUsername, toUsername, amount)
        if err != nil </span><span class="cov3" title="2">{
                if errors.Is(err, repository.ErrUserNotFound) </span><span class="cov1" title="1">{
                        return apperror.NewNotFound(fmt.Sprintf("users not found: %s, %s", fromUsername, toUsername), err)
                }</span>
                <span class="cov1" title="1">return apperror.NewInternal("failed to make money transaction", err)</span>
        }
        <span class="cov3" title="2">_, err = s.transferRepo.CreateMoneyTransfer(c, fromUsername, toUsername, amount)
        if err != nil </span><span class="cov1" title="1">{
                return apperror.NewInternal("failed to create transfer", err)
        }</span>

        <span class="cov1" title="1">return tx.Commit()</span>
}

// BuyItem adds an item to user's inventory.
func (s *Service) BuyItem(c context.Context, username, itemName string) error <span class="cov8" title="9">{
        itemToBuy, err := s.storeRepo.GetItemInfo(c, itemName)
        if err != nil </span><span class="cov3" title="2">{
                if errors.Is(err, repository.ErrInvalidItemName) </span><span class="cov1" title="1">{
                        return apperror.NewBadReq("invalid item name", err)
                }</span>
                <span class="cov1" title="1">return apperror.NewInternal("failed to get item info", err)</span>
        }

        <span class="cov8" title="7">tx, err := s.dbConn.BeginTx(c, nil)
        if err != nil </span><span class="cov1" title="1">{
                return apperror.NewInternal("failed to buy item", err)
        }</span>
        <span class="cov7" title="6">defer tx.Rollback()

        dbUsr, err := s.userRepo.GetUserForUpdate(c, username)
        if err != nil </span><span class="cov3" title="2">{
                if errors.Is(err, repository.ErrUserNotFound) </span><span class="cov1" title="1">{
                        return apperror.NewNotFound("user not found", err)
                }</span>
                <span class="cov1" title="1">return apperror.NewInternal("failed to get user", err)</span>
        }

        <span class="cov6" title="4">newCoinsCount := dbUsr.Coins - int32(itemToBuy.ItemPrice)
        if newCoinsCount &lt; 0 </span><span class="cov1" title="1">{
                return apperror.NewBadReq("not enough money", ErrNotEnoughMoney)
        }</span>

        <span class="cov4" title="3">_, err = s.userRepo.UpdateBalance(c, dbUsr.UserID, newCoinsCount)
        if err != nil </span><span class="cov1" title="1">{
                return apperror.NewInternal("failed to update balance", err)
        }</span>

        <span class="cov3" title="2">err = s.inventoryRepo.AddItemToInventory(c, dbUsr.UserID, itemName)
        if err != nil </span><span class="cov1" title="1">{
                return apperror.NewInternal("failed to add item to inventory", err)
        }</span>

        <span class="cov1" title="1">return tx.Commit()</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
